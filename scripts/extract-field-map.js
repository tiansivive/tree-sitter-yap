#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const vm = require('vm');

const grammarPath = path.resolve(__dirname, '..', 'grammar.js');

function createDsl() {
  const seq = (...children) => ({ type: 'SEQ', children });
  const choice = (...children) => ({ type: 'CHOICE', children });
  const repeat = rule => ({ type: 'REPEAT', rule });
  const repeat1 = rule => ({ type: 'REPEAT1', rule });
  const optional = rule => ({ type: 'OPTIONAL', rule });
  const token = rule => ({ type: 'TOKEN', rule });
  const alias = (value, named) => ({ type: 'ALIAS', value, named });
  const field = (name, rule) => ({ type: 'FIELD', name, rule });
  const grammar = config => config;
  const prec = (precedence, rule) => ({ type: 'PREC', assoc: 'none', precedence, rule });
  prec.left = (precedence, rule) => ({ type: 'PREC', assoc: 'left', precedence, rule });
  prec.right = (precedence, rule) => ({ type: 'PREC', assoc: 'right', precedence, rule });
  return { seq, choice, repeat, repeat1, optional, token, alias, field, grammar, prec };
}

function loadGrammar() {
  const source = fs.readFileSync(grammarPath, 'utf8');
  const sandbox = {
    module: { exports: {} },
    exports: {},
    require,
    console,
    ...createDsl(),
    __dirname: path.dirname(grammarPath),
    __filename: grammarPath,
  };
  vm.runInNewContext(source, sandbox, { filename: grammarPath });
  return sandbox.module.exports;
}

function collectFields(rule) {
  const fields = new Set();
  walk(rule, node => {
    if (node && typeof node === 'object' && node.type === 'FIELD') {
      fields.add(node.name);
    }
  });
  return Array.from(fields).sort();
}

function walk(node, visit) {
  if (node === undefined || node === null) return;
  visit(node);
  if (Array.isArray(node)) {
    node.forEach(n => walk(n, visit));
    return;
  }
  if (node instanceof RegExp) return;
  if (typeof node !== 'object') return;

  for (const value of Object.values(node)) {
    if (value === node) continue;
    if (value === undefined || value === null) continue;
    if (Array.isArray(value) || typeof value === 'object') {
      walk(value, visit);
    }
  }
}

function evaluateRule(ruleFn, proxy) {
  return typeof ruleFn === 'function' ? ruleFn(proxy) : ruleFn;
}

function formatOutput(entries) {
  const lines = [
    '// Auto-generated by scripts/extract-field-map.js',
    '// Run: npm run generate:fieldmap',
    'export const yapFieldMap = {',
  ];
  for (const [name, fields] of entries) {
    lines.push(`  ${JSON.stringify(name)}: [${fields.map(f => `'${f}'`).join(', ')}] as const,`);
  }
  lines.push('} as const;');
  lines.push('');
  lines.push('export type YapNodeType = keyof typeof yapFieldMap;');
  lines.push('export type YapFieldMap = typeof yapFieldMap;');
  lines.push('export type YapFieldNames<N extends YapNodeType> = YapFieldMap[N][number];');
  lines.push('');
  return lines.join('\n');
}

function main() {
  const grammar = loadGrammar();
  const rules = grammar.rules || {};
  const refProxy = new Proxy(
    {},
    { get: (_, name) => ({ type: 'RULE_REF', name }) }
  );

  const entries = Object.keys(rules)
    .sort()
    .map(name => [name, collectFields(evaluateRule(rules[name], refProxy))]);

  const output = formatOutput(entries);
  
  const outputDir = path.resolve(__dirname, '..', 'bindings', 'node');
  const outputFile = path.join(outputDir, 'yap-field-map.ts');
  
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  fs.writeFileSync(outputFile, output);
  console.log(`Generated field map at ${outputFile}`);
}

main();
